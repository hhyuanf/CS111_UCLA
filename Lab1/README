Group Member       ID  Numbers
Jingyuan Fan        904186250

Lab1.a
  Function make_command_stream takes one byte at a time from user's script and ignores any white space and comments until it finds a valid character. The character is then stored in the variable 'string' and the script file is converted into character stream. 
  The character stream is then passed to function 'c2tStream' to be converted into tokens. I define token as a struct which contains a token_type and a string member. The token_type indicates which kind of token is stored in the token stream, and for word_token I store the word in the string member. After the conversion I put a end_token at the end of the token stream.
  I pass the token stream into function 'read_command_stream' which analyze the structure of command indicated by the sequence of tokes in the stream. For example, a && token will leads to a root command structure with member 'type' set to AND and two command pointers pointed to the root command structures of left part and right part. a || token will results in a similar sequence of operations. The parsing process will continue until a simple command is found and constructed. Whenever meeting a left parenthesis, it will return the function parse_and_or with subsequent token stream as argument until a right parenthesis or another left parenthesis which will leads the program to another recursion. The result is a tree-like command data structure.
  When the command is generated, it is then passed to function 'print_command' to display the command on screen. 
  The timetrash program works well with the given test samples in both scripts. When a valid command is generated, it displays on screen. While a bad command is detected, it prompts the user with categorized error information.

Lab1.b
  In lab1b, I finished the part for executing commands which were parsed and structured from lab1a. The command tree generated by function 'read_command_stream' is passed to function 'execute_command' and switched by its root command's type, in order to decide which sub-executing function to enter, which are:
-execute_and_command:
  First execute the left command branch, check whether a 1 is returned, if so then go executing right branch. Otherwise return the status of left branch command and ignore right branch.
-execute_or_command:
  Similar to execute_and_command, except it checks whether the left branch returns a non-zero in order to execute the right branch.
-execute_pipe_command:
  It creates a pipe with two file descriptors and forks two child processes for each branch. Each of the file descriptors is passed to the corresponding child process and set its file descriptor table in order to pipeline those two processes.
-sequence_command:
  It executes sub-branch commands in sequence, the status is determined by the last branch executed.
-subshell_command:
  It first sets up the input and output field, then forks a child process and goes into its subshell commands.
-simple_command:
  It first sets up I/O fields, then forks a child process and call function 'execvp' to execute the commands stored in word field.
  We have tested the codes with file 'testPartB' which contains a set of commands. Although we tried hard to ensure the codes will correctly run for lab1a and lab1b, we think there are still bugs not yet discovered at this stage. 

Lab1.c
  First, I got output and input of each command tree, and every word for each simple command, and treated word the as input. Then check the dependency between each two commands, including input of the first command and output of second command, output of the first command and input of the second command(because we cannot possibly know which command would finish first), and output of the first command and output of the second command(because these two commands may alter same inputs). Then built the matrix as shown in the slides to eventually realize parallel execution.
  After running the test case testPartC.sh, we get the following results:
	Running time for Timetrash in parallel mode is
	0.00user 0.00system 0:01.01elapsed 0%CPU (0avgtext+0avgdata 3856maxresident)k
	0inputs+72outputs (0major+7179minor)pagefaults 0swaps
	Running time for Bash Shell is
	0.00user 0.00system 0:04.02elapsed 0%CPU (0avgtext+0avgdata 5616maxresident)k
	0inputs+72outputs (0major+7848minor)pagefaults 0swaps
	Comparing Output......
	No Difference. Test for part C done.


